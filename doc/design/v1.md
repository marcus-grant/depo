# Design Requirements — v1.0

This is the design document for depo going to version `1.0.0`.
Read this to understand some of
the design decisions made in [the MVP plan](./mvp.md).
Also a holding document for post version `1.0` considerations.

## Purpose

Make the project safe and pleasant to share publicly,
while preserving MVP invariants and
enabling richer text workflows *(editor, aliases, versioning)*.

All v1.0 features must be additive: existing immutable item links remain stable.

---

## 1. Preserve MVP Invariants

All MVP invariants remain in force:

- Items remain immutable and content-addressed.
- `/{code}/raw` always returns exact bytes.
- `/{code}/info` remains the canonical viewer surface.
- No anonymous uploads by default (configurable, but default remains safe).
- SQLite remains first-class.
- Before starting the sequence of new capabilities,
  - Nail down utility scripts to handle database migrations

---

## 2. New Capabilities (v1.0)

### 2.1 Aliases (mutable surface)

Aliases provide mutability without mutating Items.

#### Alias Model

- `Alias`
  - `name` (unique, canonicalized)
  - `head_code` (FK → Item.code)
  - `owner_user_id` or `owner_group_id`
  - `visibility` (`private`, `unlisted`, `public`)
  - `created_at`, `updated_at`
- `AliasRevision`
  - `alias_name` or `alias_id`
  - `code` (FK → Item.code)
  - `created_at`
  - optional `message`
  - optional `author_user_id`

#### Alias Routes

- `GET /a/{name}` → redirects to current `/{code}/info`
- `GET /a/{name}/raw` → raw of current head
- `GET /a/{name}/history` → revisions list
- Optional pinning: `GET /a/{name}/v/{code}` → view a specific revision

#### Alias Rules

- Updating an alias creates a new Item and advances `head_code`.
- Old codes remain valid forever.

### 2.2 Editor (HTMX-first)

Add an editor for text-based content.

#### Alias UX

- `GET /a/{name}/edit` for alias-backed editable documents
- `GET /{code}/fork` (optional) to create alias from an immutable item
- Autosave optional; manual save is acceptable for v1.0

#### Alias Save behavior

- Editor POST creates a new TextItem (new immutable code).
- Alias is advanced to point to the new code.
- A revision entry is added.

### 2.3 Invitations, registration, and account management

Keep self-hosting simple; default remains invite-only.

#### Invite Tokens

- `InviteToken`
  - `token_hash` (store hash only)
  - `email` (optional)
  - `created_at`, `expires_at`, `used_at`
  - `created_by_user_id`
- Registration:
  - invite link + registration form (email + password)
  - mark token as used

#### Password change

- authenticated change-password flow

#### Password reset (optional in v1.0)

- similar token model; allow disabling for self-hosters

### 2.4 Authorization evolution (users → groups)

Introduce groups if/when needed, but avoid making it mandatory for simple installs.

#### Baseline (v1.0 minimum)

- Per-item visibility + owner user.
- Sharing by link (`unlisted`) remains supported.

#### Groups (optional, but model-ready)

- `Group`, `Membership`
- `ItemAccess` / `AliasAccess` (group grants)
- Moderator role as a capability set

### 2.5 Object store origin + local FS cache (LRU) (optional in v1.0)

Storage becomes pluggable:

- Origin can be filesystem or object store.
- Local filesystem cache uses LRU eviction.

#### Object store origin - Hard rules**

- Content identity remains bytes-hash based.
- Cache never changes bytes, only mirrors.

### 2.6 Metadata caching (RAM/Redis) (optional in v1.0)

Introduce metadata cache to reduce DB queries.

#### Metadata caching pattern**

- `CachedRepository` wraps `Repository`:
  - read-through on `get_by_code`
  - write-through on `persist` / alias updates
- Cache stores DTOs (serializable), not ORM instances.

---

## 3. Security Requirements (v1.0)

### 3.1 Rendering safety

- Never render potentially dangerous formats as executable content in `/info`:
  - HTML and SVG are displayed as highlighted/escaped by default
- Markdown rendering must be sanitized:
  - strip scripts/events
  - safe link handling
- Content Security Policy (CSP) should be configured for `/info`.

### 3.2 Upload and abuse controls

- Rate limiting (configurable; basic in-process ok, Redis-backed optional)
- Size limits enforced consistently for all endpoints
- MIME sniffing is authoritative; declared types are hints

### 3.3 URL shortening safety

- LinkItem only allows safe schemes by default (`http`, `https`)
- optional protections:
  - block private network targets
  - add rel/noopener behavior in UI

---

## 4. Interfaces (v1.0 additions)

### 4.1 Alias repository interface

```python
from typing import Protocol, Optional, List
from dataclasses import dataclass

@dataclass(frozen=True)
class AliasMeta:
    name: str
    head_code: str
    visibility: str
    updated_at: str

@dataclass(frozen=True)
class AliasRevisionMeta:
    alias_name: str
    code: str
    created_at: str
    message: Optional[str] = None

class AliasRepository(Protocol):
    def get(self, name: str) -> Optional[AliasMeta]:
        ...

    def resolve_head_code(self, name: str) -> Optional[str]:
        ...

    def set_head_code(
        self, name: str, new_code: str, *, message: Optional[str] = None
    ) -> AliasMeta:
        '''Appends revision and advances head atomically.'''
        ...

    def history(self, name: str, *, limit: int = 50) -> List[AliasRevisionMeta]:
        ...
```

### 4.2 Editor save use-case interface (recommended)

```python
from typing import Protocol, Optional

class EditUseCase(Protocol):
    def save_new_version(
        self,
        *,
        alias_name: str,
        content_bytes: bytes,
        requested_format: str,
        title: Optional[str],
        author_user_id: str,
        message: Optional[str] = None,
    ) -> str:
        '''Returns new immutable item code and updates alias head.'''
        ...
```

---

## 5. Migration from the old Django project

- Old project remains operational while v0.0.1 is built.
- Data copy occurs later:
  - copy payload files
  - copy tables (or transform rows) into the new schema
- Codes must remain stable; hashing utility module remains authoritative.

---

## 6. v1.0 acceptance criteria

Minimum bar to start promoting publicly:

- Invite-based registration works
- Authenticated uploads are robust and stream safely (no large memory spikes)
- `/info` rendering is safe (no HTML/SVG execution; sanitized markdown)
- Alias + history works (editable docs)
- Basic abuse controls (size limit, rate limit, logging)
- SQLite remains first-class, docs for self-hosting are clear

## 7. Future Considerations (Post–v1.0)

The following features are not required for v1.0,
but the architecture is intentionally designed so
they can be added without violating core guarantees or
requiring a rewrite.

### 7.1 Ephemeral access and time-limited sharing

- Support temporary access to content via:
  - aliases or access tokens with a TTL
  - optional password or shared secret
- Expiration revokes access, not content identity.
- Intended for quick, low-friction sharing between trusted users.

### 7.2 Retention policies and automatic purging

- Configurable retention policies based on:
  - last access time
  - visibility (private / unlisted / public)

- Two-phase purge model
  - logical removal (no longer accessible)
  - physical deletion (storage reclaimed after grace period)
  - Purge is opt-in and disabled by default for self-hosters.

### 7.3 Moderation and administrative deletion

- Moderators and administrators must be able to:
  - Hide or remove abusive or illegal content
  - Permanently delete content when required
    - Deletion may be:
      - Soft (tombstoned)
      - Hard (fully removed)
  - Codes are never reused, even after deletion.

### 7.4 Storage evolution

- Object store as origin with local filesystem cache (LRU eviction).
- Background garbage collection for unreferenced or purged payloads.
- Storage backend remains replaceable and opaque to higher layers.
- **Content/metadata separation:** Current design couples content identity
  and per-upload metadata in the `items` table. Future split:
  - `content` table: hash_full PK, format, size_b (immutable blob identity)
  - `items`/aliases become metadata pointers to content (uid, perm, tags)
  - Multiple aliases referencing same content achieves storage deduplication
    while preserving per-user metadata
  - This converges with the alias system (§2.1)—aliases *are* the per-user
    metadata layer rather than a separate concept
  - Subtype tables (text_items, pic_items, link_items) would FK to content,
    not items

#### Async DB ramp plan

- MVP: `check_same_thread=False`, synchronous repo, single process
- V1: Define `RepoProtocol` (abstract interface).
  - Keep SQLite sync behind it.
  - Add WAL mode (`PRAGMA journal_mode=WAL`).
  - Consider `aiosqlite` as thin async wrapper.
- V2: PostgreSQL via `asyncpg` implements `RepoProtocol`.
  - True async, connection pooling, concurrent writes.
  - The protocol boundary from V1 makes this a new implementation, not a refactor.

### 7.5 Metadata and access caching

- In-memory or Redis-backed caching of item and alias metadata.
- Cache is strictly a performance optimization;
  - database remains authoritative.

### 7.6 Richer text tooling

- Enhanced editors for text and code content.
- Optional features such as:
  - diffs between revisions
  - syntax-aware tooling
  - markdown internal linking and references
- All tooling builds on immutable items and alias-based mutability.

### 7.7 Authorization expansion

- Optional group-based permissions and moderation roles.
- Invite-based registration remains the default posture.
- Configuration-first approach for self-hosted deployments.

### 7.8 Advanced content classification

MVP classification uses simple priority:
explicit request > MIME hint > magic bytes > filename extension.

#### Web layer format hints

- Expose `requested_format` as query param on upload endpoint.
  - Decide on interface after browser route handlers are implemented.
- Config option to allow naive image uploads without Pillow verification
  - (safe for small insular groups, potentially dangerous otherwise).

#### Future enhancements (less important)

- **Text content analysis**
  - Shebang detection (`#!/usr/bin/env python`)
  - JSON/YAML structure detection from content
  - Markdown frontmatter detection
  - Heuristics for code vs prose

- **Confidence-based classification**
  - Return ranked candidates with confidence scores
  - Source attribution (magic bytes, filename, content analysis)
  - Support multiple plausible classifications

- **User-facing classification UI**
  - Prefilled format dropdown based on inference
  - Live preview with suggested syntax highlighting
  - User correction before submission
  - Feedback loop for improving heuristics

Classification remains deterministic for identical inputs.
User corrections do not alter inference logic — they override it per-upload.

## 8. Tagging and Discovery (v1.0)

Tagging is introduced as a **discovery and organization mechanism**,
not an identity or access mechanism.

Tags are intentionally designed to be flexible,
mutable metadata that support browsing and filtering without
affecting content identity or stability.

---

### 8.1 Core principles

- Tags are **pure metadata**.
- Tags do not affect:
  - hashing or short codes
  - content identity
  - `/raw` behavior
- Tags are inherently **mutable** and may change over time.
- Tag-based views are **not stable identifiers**.

---

### 8.2 Alias-first tagging (v1.0 default)

In v1.0, tags are primarily associated with **aliases**, not immutable items.

#### Alias-first tagging rationale

- Aliases represent the *current, user-facing version* of content.
- Aliases are mutable by design and can move across versions.
- Tagging aliases ensures that:
  - tags remain relevant across edits
  - editing does not require re-tagging every immutable version
  - discovery reflects current user intent, not historical artifacts

This aligns tags with how users typically think about organization:
> “How do I want to group or find this document right now?”

#### Alias-first tagging - Implication

- When an alias advances to a new item version, its tags continue to apply.
- Historical immutable items remain untagged unless explicitly annotated.

---

### 8.3 Tagging immutable items (future-compatible)

The model is intentionally designed so
tags **may also be associated with immutable items** in the future.

Item-level tagging is useful for:

- archival or forensic classification
- moderation or administrative annotation
- describing intrinsic properties of a specific version
  (e.g. language, format, content classification)

If introduced, item-level tags:

- are stored separately from alias tags
- do not propagate across versions
- reflect historical truth about a specific item’s bytes

This allows both perspectives to coexist:

- **Alias tags** → organization, navigation, discovery
- **Item tags** → classification, analysis, history

---

### 8.4 Discovery endpoints

A tag-based discovery endpoint is provided:

- `GET /tag/{name}`

This endpoint returns:

- a list of aliases or items currently associated with the tag
- a faceted list of co-occurring tags (by occurrence) to enable further filtering

The result set may change over time as:

- tags are added or removed
- aliases advance
- content is deleted or purged

---

### 8.5 Untagged content

- Content with no tags has **no tag records** (null / absence).
- No automatic or synthetic `untagged` tag is created.
- Views for untagged content, if desired,
  - are implemented as explicit filters or UI affordances.

---

### 8.6 Permissions

- Only authorized users may add or remove tags.
- Public users may view tags and tag-based discovery results
  - subject to content visibility rules.

---

### 8.7 Non-goals

- Tags do not create canonical URLs for content.
- Tags do not replace aliases.
- Tags do not imply ownership, access rights, or permanence.

### 8.8 Example data model (illustrative)

The following tables illustrate one possible schema that
supports alias-first tagging while remaining compatible with
future item-level tagging.

These are **examples**, not hard requirements.

#### Tag

Represents a canonical tag label.

- `id`
- `name` (unique, canonicalized, case-insensitive)
- `created_at`

#### AliasTag

Associates a tag with an alias (v1.0 default).

- `alias_id`
- `tag_id`
- `created_at`
- optional `created_by_user_id`

##### AliasTag Properties

- Many-to-many relationship.
- Tags persist across alias revisions.
- Removing a tag only affects discovery, not content identity.

#### (Future) ItemTag

Associates a tag with a specific immutable item.

- `item_code` (FK → Item.code)
- `tag_id`
- `created_at`
- optional `created_by_user_id`
- optional `reason` (e.g. moderation, classification)

##### ItemTag Properties

- Tags apply only to that specific immutable version.
- Tags do not propagate when an alias advances.
- Intended for archival, moderation, or analytical use cases.

#### Notes on querying

- `/tag/{name}` may return:
  - aliases (preferred for user-facing discovery), and/or
  - items (if item-level tagging is enabled)
- Faceted tag counts are derived dynamically from the result set.
- No tag table participates in hashing, identity, or code generation.

This separation allows the system to
support both **organizational tagging** and **historical annotation** without
conflating their semantics.

### Future: Repository Architecture

The current SQLite implementation lives in a single module (`repo/sqlite.py`).
As the system grows, consider this structure:

#### Query construction abstraction

Two options under consideration:

**Option A — Query constants module:** Simple string constants per dialect.
Minimal complexity, sufficient if query count stays small.

**Option B — Query builder:** Method-chaining builder supporting
SELECT, FROM, WHERE, IN, LIKE, INSERT INTO, JOIN.
Enables dialect switching (SQLite `?` vs PostgreSQL `%s`).
Higher upfront cost, pays off with PostgreSQL migration.

Additionally, a **mapper module** to handle WritePlan → query params
and row results → Item subtypes would centralize (de)serialization
currently spread across SqliteRepository.

#### Single-transaction dedupe

Current dedupe uses `get_by_full_hash()` before `insert()` (two transactions).
PostgreSQL supports `INSERT ... ON CONFLICT DO NOTHING RETURNING *` for
single round-trip dedupe. SQLite equivalent is `INSERT OR IGNORE` with
`changes()` check.
Consider when optimizing write path.

#### Entity-based split

```txt
repo/
├── __init__.py          # Re-exports public API
├── errors.py            # Shared exceptions
├── schema.sql           # Unified schema (FK relationships)
├── base.py              # init_db(), shared utilities
├── items.py             # ItemRepository (items + subtypes)
├── users.py             # UserRepository (future)
├── tags.py              # TagRepository (future)
```

Each repo owns its tables and row mappers. Connection injected for testability.

#### Multi-database support

When adding Postgres support:

```txt
repo/
├── protocol.py          # ItemRepository Protocol (abstract interface)
├── errors.py            # Shared exceptions
├── sqlite/
│   ├── schema.sql
│   ├── items.py         # SqliteItemRepository
│   └── ...
├── postgres/
│   ├── schema.sql
│   ├── items.py         # PostgresItemRepository
│   └── ...
```

**What stays the same:**

- Row mappers (dict → domain model)
- Error types
- Method signatures
- Most queries (named params work in both)

**What differs:**

- Connection handling (sqlite3 vs asyncpg)
- Schema syntax (INTEGER PRIMARY KEY vs SERIAL)
- Async patterns for Postgres

Factory function selects implementation based on config.
Orchestrator depends on Protocol, concrete impl injected at startup.

## 9. Web Layer Improvements (post-MVP)

### 9.1 Error handling

- Centralize error messages across the ingestion pipeline.
  - Currently scattered `ValueError` raises with inline strings.
  - Started: `util/errors.py` with `PayloadTooLargeError`. Expand this pattern.
- Refactor into specific exception types for better status code mapping
  - (400 vs 413 vs 422).
  - Done: PayloadTooLargeError -> 413. More needed.
- Test `ImportError` path when Pillow is missing (currently returns 501 uncaught).
- Plan logging architecture before v1
  - structured logging, request IDs, error tracking.
- Improve error response strategy:
  - 500 page for unexpected item types (currently exists but needs review)
  - Split routes.py into per-concern routers to keep error handling manageable

### 9.2 API response improvements

- Proper JSON serialization for `/api/{code}/info` via
  - FastAPI's Pydantic response models.
- Expand `X-Depo-*` headers beyond...
  - Code, Kind, Created (format, size, hash).
- FQDN config option to return full URL in...
  - upload response body instead of bare short code.
- Per-user config for response format preferences (post-MVP, towards v1 multi-user).

### 9.3 URL classification pipeline

- URLs should enter as payload_bytes, not special-cased link_url param
- Classification pipeline should detect and handle URLs uniformly
- Rethink URL size limit validation when URLs become payload_bytes
- link_url param on ingest() becomes the explicit override path
- Client-side vs server-side classification evaluation needed
- Re-add Link optgroup to format dropdown once classification handles it

### 9.4 Route refactoring

- Split routes.py into per-concern routers (upload, info, api, core)
- Canonical raw route: /raw/{code} instead of /api/{code}/raw
- requested_format query param: decide interface after browser usage clarifies it

### 9.5 Browser UI improvements

- Styling and structural primitives (own PR):
  - dither patterns (1-bit bitmap fills)
  - TUI borders (box-drawing characters)
  - hard-edge dither shadows
  - typography hierarchy
- Upload form progressive complexity:
  - image paste from clipboard
  - file picker
  - URL detection in textarea
  - auto-classification preview
  - editable metadata population
- Link page previews (OpenGraph fetching)

### 9.6 Configuration and limits

- Raise default upload limit to 64 MiB (guests disabled by default)
- Refactor size limits to use config loading infra
- Access tracking per item (UPDATE on access for recent/popular surfacing)

### 9.7 Test and dev infrastructure

- t_client fixture to replace repeated make_client(tmp_path)
- Factory consolidation (evaluate merging small factory modules)
- Manual route testing with posting collections saved to repo
- Migrate _looks_like_url to service/classify
